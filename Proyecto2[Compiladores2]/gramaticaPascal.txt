INICIO -> PROYECTO

PROYECTO -> program ID ; CABECERA CUERPO begin INSTRUCCIONES end .


// *************************************** CABECERA DEL PROGRAMA ***************************************


CABECERA -> CABECERA CABECERA'
			| CABECERA'
			| epsilon
			
CABECERA' -> VARIABLE
			| DECLARACION_OBJETOS
			| CONSTANTE

VARIABLE -> VARIABLE var VARIABLE'
			| var VARIABLE'
			| epsilon

VARIABLE' -> VARIABLE' DECLARACION : TIPO VARIABLE'' ;
			| DECLARACION : TIPO VARIABLE'' ;

VARIABLE'' -> = VALOR
			| epsilon

LISTA_DEC->  LISTA_DEC LISTA_DEC'
			| LISTA_DEC'

LISTA_DEC' -> DECLARACION : TIPO

DECLARACION -> DECLARACION , id
			| id
			
DECLARACION_OBJETOS -> type id = DECLARACION_OBJETOS'

DECLARACION_OBJETOS' -> ARREGLO
						| OBJETO

ARREGLO -> array [ num .. num ] of TIPO ;

OBJETO -> object VARIABLE end ;

TIPO -> string
		| integer
		| real
		| boolean
		| void
		| object
		| id
		
VALOR -> ASIGNACION1
		|cadena
		|EXP
		|EXP_LOG

CONSTANTE -> CONSTANTE CONSTANTE'
			|CONSTANTE'
			
CONSTANTE' -> id = VALOR ;
		
		

// *************************************** CUERPO DEL PROGRAMA ***************************************
		

CUERPO -> CUERPO CUERPO'
		| CUERPO'
		| epsilon
		
CUERPO' -> FUNCION
		  | PROCEDIMIENTO
		  | Eof
		
FUNCION -> function id PARAMETROS : TIPO ; VARIABLE ANIDAR begin INSTRUCCIONES end ;

			 
PROCEDIMIENTO -> procedure id PARAMETROS ; VARIABLE ANIDAR begin INSTRUCCIONES end ;

procedure contar(x, y:integer); 
	
	var z:integer;
	
	begin
		z:=x+y;
	end;

ANIDAR -> ANIDAR ANIDAR'
		| ANIDAR'
		
ANIDAR' -> FUNCION
		| PROCEDIMIENTO
		| epsilon
		
PARAMETROS -> ( PARAMETROS' )
			| ( )
			| epsilon

PARAMETROS' -> PARAMETROS' ; PARAMETROS''
				| PARAMETROS''
					
PARAMETROS'' ->  LISTA_DEC
				 | var LISTA_DEC

LLAMADA -> id ( LLAMADA' ) ;

LLAMADA' -> LLAMADA' , VALOR
			| VALOR
			| epsilon

// **************************** CONDICIONES ****************************

CONDICION -> EXP_LOG  

CONDICION_NUM -> CONDICION_LOG
				| <
				| >
				| <=
				| >=

CONDICION_LOG -> =
				|<>		
			
// **************************** INSTRUCCIONES ****************************

EXP -> EXP + EXP
	|EXP - EXP
	|EXP * EXP
	|EXP / EXP
	|( EXP )
	|- EXP
	|entero
	|real
	|ASIGNACION1

EXP_LOG -> EXP_LOG and EXP_LOG						3
		|EXP_LOG or EXP_LOG							3
		|( EXP_LOG )								3
		|( EXP CONDICION_NUM EXP )					5
		|( EXP_LOG CONDICION_LOG EXP_LOG )			5
		| EXP CONDICION_NUM EXP						3
		|not EXP_LOG								2
		|true										1
		|false										1
		|ASIGNACION1

INSTRUCCIONES -> INSTRUCCIONES INSTRUCCION
				| INSTRUCCION;

INSTRUCCION -> IF
			| ASIGNACIONES
			| LLAMADA
			| Exit( VALOR ) ;

WRITE -> write ( LISTA_CASE' ) ;

WRITELN -> writeln ( LISTA_CASE' ) ;

ASIGNACIONES -> ASIGNACION : = VALOR ;

ASIG_AREGLO -> ASIGNACION [ EXP ] : = VALOR ;

ASIGNACION -> ASIGNACION . id				
			| id

ASIGNACION1 -> id ASIGNACION2;

ASIGNACION2 ->  . ASIGNACION
				| ( LLAMADA' )
				| [ EXP ] 
				| epsilon

EXIT -> exit ( VALOR ) FIN

ASIG_ARREGLO -> ASIGNACION [  EXP  ]  : =  VALOR  ;

// **************************** SENTENCIAS DE CONTROL *****************************


IF -> if CONDICION then begin INSTRUCCIONES end ; 'IF

IF' ->   ELSE_IF IF''
		|ELSE
		|epsilon

IF'' -> ELSE
		|epsilon

ELSE_IF -> ELSE_IF else if CONDICION then begin INSTRUCCIONES end ;
		| else if CONDICION then begin INSTRUCCIONES end ;

ELSE -> else begin INSTRUCCIONES end ;
		| epsilon

CASE -> case id of LISTA_CASE ELSE_CASE end;

LISTA_CASE -> LISTA_CASE LISTA_CASE' : begin INSTRUCCIONES end ;
			| LISTA_CASE' : begin INSTRUCCIONES end ;
			
LISTA_CASE' -> LISTA_CASE , VALOR
			| VALOR

ELSE_CASE -> else begin INSTRUCCIONES end;
			| epsilon

WHILE -> while CONDICION do begin INSTRUCCIONES end ;

REPEAT -> repeat begin INSTRUCCIONES end until CONDICION ;

FOR -> for id : = EXP to EXP do begin INSTRUCCIONES end ;










type Cuadrado = object
	var altura:int;
end;

type Rectangulo = object
	var altura, ancho:int;
end;

type Cuadrilatero = object
	var cuadrado:Cuadrado;
	var rectangulo:Rectangulo ;
end;







------------------------------- PRUEBAS -------------------------------

5+5=2 and (6*(1+1))<=15 or (5+5-(6*1))>hola

5+5 = 2 and 6*(1+1)<=15

(false or true) and (5+5*(5-1))<=100

true and false and (false=(5<=(10))) or ((false<>true) and (true or false))

5+5*(3+(2+69))-5+6*(5+(5*3))

5+(2+3)+(2+3)+3*(2+3) + (1*0+1*0)-(1*0+1*0)

(1*0+1*0)-(1*0+1*0)

T1 = 2 + 3
T2 = 5 + T1
T3 = T2 + T1




(5*(2+1))=(5*(2+1)) or 10>=10 and 5<>10
repeat begin end until (5*(2+1))=(5*(2+1)) or 10>=10 and 5<>10;
while ((10<100 or 10>200 and 10<>20) or (5>0)) or (5=0) do begin  end ;

 
((10<100 or 10>200 and 10<>20) or (5>0)) or (5=0) ***********************************************

if 10<100 goto L1
goto L2
L2: if 10>200 goto L3
goto L4
L3: if 10<>20 goto L5
goto L6
L6: if 5>0 goto L7
goto L8
L8: if 5=0 goto L9
goto L10


L1:
L5:
L7:
L9:

L4:
L10:

(10<100 or 10>200 and 10<>20) or (5>0) ***********************************************

if 10<100 goto L1
goto L2
L2: if 10>200 goto L3
goto L4
L1, L3: if 10<>20 goto L5
goto L6
L4, L6: if 5>0 goto L7
goto L8

468
L5:
L7:

L8:

(10<100 and 10>200) and 10<>20 ***********************************************

if 10<100 goto L1
goto L2
L1: if 10>200 goto L3
goto L4
L3: if 10<>20 goto L5
goto L6

L5:

L2:
L4:
L6:



(10<100 or 10>200 and 10<>20) ***********************************************

if 10<100 goto L1
goto L2
L2: if 10>200 goto L3
goto L4
L3: if 10<>20 goto L5
goto L6

L1:
L5:

L4:
L6:

(10<100 or 10>200) or (5>1 and 5>2) ***********************************************

if 10<100 goto L1
goto L2
L2: if 10>200 goto L3
goto L4
L4: if 5>1 goto L5:
goto L6
L5: if 5>2 goto L7
goto L8:

L1:
L3:
L7:

L6:
L8:



(10<100 or 10>200) or 5>1 ***********************************************

if 10<100 goto L1
goto L2
L2: if 10>200 goto L3
goto L4
L4: if 5>1 goto L5:
goto L6:

L1:
L3:
L5:

L4:
L6:

10<100 or 10>200 ***********************************************

if 10<100 goto L1
goto L2
L2: if 10>200 goto L3
goto L4

L1:
L3:

L4:



10<100 and 10>200 ***********************************************

if 10<100 goto L1
goto L2
L1: if 10>200 goto L3
goto L4

L3:

L2:
L4:


if(10>10 and 10>5) then
begin

end
else if (10=10 and 10>5) then
begin

end
else
begin

end;

((10>1 and 5>5) or (true=1) = false) ***********************************************

if 10>1 goto L1;
goto L2;
L1: if (5>5) goto L3;
goto L4;
L2, L4: if (true = 1) goto L5;
goto L6;

L3:verdadero




(10<100 and 10>200) or 5>1

if(10<100) goto L1
goto L2
L1: if (10>200) goto L3
goto L4:
L2, L4: if (5>1) goto L5
goto L6

L3:
L5:

L6:


((10<100 and 10>200) == (10<100 and 10>200)) and  5!=10 **********************************************


if(10<100) goto L1
goto L2
L2: if(10>200) goto L3
goto L4

L3: T = 1

L2: L4: T = 0


if(10<100) goto L5
goto L6
L6: if(10>200) goto L7
goto L8

L7: 

L6: L8: 


if (T==T)

///********************************************************



STACK [1] = 0; 
STACK [2] = 0; 
STACK [3] = 0; 
T1 = 1 * 0; 
T2 = T1 + T1; 
T3 = T2 - T2; 
STACK [4] = T3; 

if ( 10 > 1 ) goto L1;
goto L2;
L1: if ( 5 > 5 ) goto L3;
goto L4;
L2: L4: if ( 1 == 1 ) goto L5; 
goto L6; 

L3: L5: T3 = 1; 
goto L7; 

L6: T3 = 0; 
L7: if ( 1 == 0 ) goto L8; 
goto L9; 

L8: T4 = 1; 
goto L10; 

L9: T4 = 0; 
L10: if ( T3 == T4 ) goto L11; 
goto L12; 

L11: STACK [5] =  1; 

L12: STACK [5] =  0; 





((5>10)=(5<>0))


5>10 and true|false

if ( 5>10 ) goto L1
goto L2
L1: if( 1 = true|false ) goto L3
goto L4


5>10 or true|false

if ( 5>10 ) goto L1
goto L2
L2: if( 1 = true|false ) goto L3
goto L4


L1: L3:

L4:



(2*(5+2)>15) and (5>10)


false or true



((10>1 and 5>5) or (true) = false)

if ( 10 > 1 ) goto L1;
goto L2;
L1: if ( 5 > 5 ) goto L3;
goto L4;
L2: L4: if ( 1 == 1 ) goto L5; 
goto L6; 

L3: 
L5: 
T0 = 1; 
goto L7; 

L6: 
T0 = 0; 
L7: if ( 1 == 0 ) goto L8; 
goto L9; 

L8: 
T1 = 1; 
goto L10; 

L9: 
T1 = 0; 
L10: if ( T0 == T1 ) goto L11; 
goto L12; 

L11: 

L12: 




((10>1 and 5>5) or (true) = false)


if ( 10>1 ) goto L1;
goto L2;
L1: if ( 5>5 ) goto L3;
goto L4;
L2: L4: if ( 1 == 1 ) goto L5;
goto L6;

L3: L5: T0 = 1;
goto L7;
L6: T0 = 0;
L7: if ( T0 == 0 ) goto L8;
goto L9;

L8:

L9:





for id : = 10*(5+5) to 20*(2*4) do begin end ;

T1 = 5 + 5; 
T2 = 10 * T1; 
T3 = 2 * 4; 
T4 = 20 * T3; 
id=T2 
L1: if ( T2 > T4 ) goto L2;
goto L1;
L2: 









Roles
	Admin
		Todo
	Maestro
		Cursos
		Publicaciones
			Avisos
			Actividades
				Examenes --> Despues de calificar envia notificacion
				Tarea
	Alumno
		Cursos
		Publicaciones
		Actividades
			Resolver examenes
			Entregar tareas
		Notas
		Notificaciones
		
		


program Main;

type Cuadrado = object
	var altura:integer;
end;

type Rectangulo = object
	var altura, ancho:integer;
end;

var uno:Cuadrado;
var dos:Rectangulo;
var total:integer;

begin

	uno.altura:=10; //--> 0
	dos.ancho:=20;	//--> 2
	total:=uno.altura+dos.ancho;
	//total:=uno.altura+dos.ancho*(total+dos.altura);
	
end.


/*
HEAP[0] = 10;
HEAP[2] = 20;
T1 = HEAP[0] ; 
T2 = HEAP[2] ; 
T3 = T1 + T2; 
STACK[2] = T3;

*******************************

HEAP[0] = 10;
HEAP[2] = 20;

T1 = HEAP[0] ; --> uno.altura
T2 = HEAP[2] ; --> dos.ancho
T3 = STACK[2] ; --> total
T4 = HEAP[1] ; --> dos.altura

T5 = T3 + T4; 
T6 = T2 * T5; 
T7 = T1 + T6; 
STACK[2] = T7;



*/



		
program Main;

type Cuadrado = object
	var altura:integer;
end;

type Rectangulo = object
	var altura, ancho:integer;
end;

type Circulo = object
	var radio:integer;
	var perimetro:integer;
end;

type Cuadrilatero = object
	var cuadrado:Cuadrado;
	var rectangulo:Rectangulo;	
	var nombre:String;
end;


type Geometria = object
	var circulo:Circulo;
	var cuadrilatero:Cuadrilatero;
end;


type Persona = object
	var nombre:string;
	var edad:integer;
end;


type Trabajador = object
	var persona:Persona;
	var puesto:string;
end;


var
	g:Geometria;
	b:string;
	c, d: integer;
	godin,godin1:Trabajador;
	numero, uno:integer;
	dos:integer=5+5*(3+(2+69))-5+6*(5+(5*3));
	flag:boolean = true and false and (false=(5<=(10))) or ((false<>true) and (true or false));
	
begin

	g.cuadrilatero.cuadrado.altura := 10;
	g.cuadrilatero.rectangulo.altura := g.cuadrilatero.cuadrado.altura;
	g.cuadrilatero.rectangulo.ancho := dos;
	g.cuadrilatero.nombre := 'Cuadrilatero1'
	g.circulo.radio := 2.5;
	b := 'Variable'  //--> 45
	c:=777;
	d:=34886677;
	godin.persona.nombre := 'Helmut'; //-->65
	godin.persona.edad := 20; //-->66
	godin.puesto:='Jefe'; //--> 67
	
	numero:=g.cuadrilatero.cuadrado.altura;
	
	godin1.persona.nombre := 'Efrain'; //-->87
	godin1.persona.edad := 21;  //--> 88
	godin1.puesto:='Jefe de jefes'; //--> 98
	
	uno:=1500;
	dos:=3;
	
end.


program Procedimientos;

var
	b:string;																			// --> STACK[0], HEAP[0-20]
	c, d: integer;																		// --> STACK[1], STACK[2]
	numero:integer;																		// --> STACK[3]

procedure contar(x, y:integer); 														// --> STACK[4], STACK[5]
	
	var z:integer;																		// --> HEAP[20-21]
	
	begin
		z:=x+y;																				
	end;
	
function factorial(n: integer): integer;												// --> STACK[6] -->HEAP[44-45]

	var x,y,z:integer;																	// --> HEAP[21-22], HEAP[22-23], HEAP[23-24]
	var saludo:string;																	// --> HEAP[24-44]
	
	begin
	
	end;	

procedure Hanoi(discos:integer; origen,aux,destino:string; var nuermo:integer);			// --> (STACK[7], HEAP[44-45]), (STACK[8], HEAP[45-65]), (STACK[9], HEAP[65-85]), (STACK[10], HEAP[85-105]), STACK[11]
	
	var x,y,z:integer;																	// --> HEAP[105-106], HEAP[106-107], HEAP[107-108]
	var saludo:string;																	// --> HEAP[108-128]
	
	begin
		
	end;
	
	
begin
end.



ASIGNACIONES -> 
				ASIGNACION 									--> getAsignaciones(Nodo, string): string (cuadrado:=, cuadrado.altura:=, cuadrilatero.cadrado.altura:=)
				: 
				= 
				VALOR										--> asignarValor(nodo[], string, int):void ()	-->		--> buscarVariableEnEntornos(string[], string):void()	--> asignarAVariable(string[], string, int, Variable, Objeto):Variable (SE HACE LA TRADUCCION)
					ASIGNACION1								--> validarAsignacionAVariable(nodo, string):string (valor)
						ASIGNACION2							--> validarAsignacionAVariable(nodo, string):string (valor)
							. ASIGNACION					--> getAsignaciones(Nodo, string): string (cuadrado:=, cuadrado.altura:=, cuadrilatero.cadrado.altura:=)	--> getResultadoDeVariable(string[]):string ()	--> asignarAVaraible1(string[], int, varaible, objeto):Object (valor)
							( LLAMADA' )
							[ EXP ]
					EXP										--> asignarValor(nodo[], string, int):void ()
					EXP_LOG									--> asignarValor(nodo[], string, int):void ()
					CADENA 									--> asignarValor(nodo[], string, int):void ()
				;					

			
			
			
			


T1 = 2 + 69; 
T2 = 3 + T1; 
T3 = 5 * T2; 
T4 = 5 + T3; 
T5 = T4 - 5; 
T6 = 5 * 3; 
T7 = 5 + T6; 
T8 = 6 * T7; 
T9 = T5 + T8; 
STACK [8] = T9; 

if ( 1 == 1 ) goto L1; 
goto L2; 
L1: if ( 1 == 0 ) goto L3; 
goto L4; 
L3: if ( 1 == 0 ) goto L5; 
goto L6; 

L5: T10 = 1; 
goto L7; 

L6: T10 = 0; 
L7: if ( 5 <= 10 ) goto L8;
goto L9;

L8: T11 = 1; 
goto L10; 

L9: T11 = 0; 
L10: if ( T10 == T11 ) goto L11; 
goto L12; 
L2: L4: L12: if ( 1 == 0 ) goto L13; 
goto L14; 

L13: T12 = 1; 
goto L15; 

L14: T12 = 0; 
L15: if ( 1 == 1 ) goto L16; 
goto L17; 

L16: T13 = 1; 
goto L18; 

L17: T13 = 0; 
L18: if ( T12 == T13 ) goto L19; 
goto L20; 
L11: L19: if ( 1 == 1 ) goto L21; 
goto L22; 
L20: L22: if ( 1 == 0 ) goto L23; 
goto L24; 

L21: L23: STACK [9] =  1; 

L24: STACK [9] =  0;

HEAP[2] = 10;
HEAP[3] = HEAP[2];
HEAP[4] = STACK[8];
PTR_H = 5;
HEAP[PTR_H] = c;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = u;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = a;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = d;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = r;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = i;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = l;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = a;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = t;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = e;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = r;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = o;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = 1;
PTR_H = PTR_H + 1;
HEAP[0] = 2.5;
PTR_H = 25;
HEAP[PTR_H] = v;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = a;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = r;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = i;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = a;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = b;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = l;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = e;
PTR_H = PTR_H + 1;
STACK[2] = 777;
STACK[3] = 34886677;
PTR_H = 45;
HEAP[PTR_H] = h;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = e;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = l;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = m;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = u;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = t;
PTR_H = PTR_H + 1;
HEAP[65] = 20;
PTR_H = 66;
HEAP[PTR_H] = j;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = e;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = f;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = e;
PTR_H = PTR_H + 1;
STACK[6] = HEAP[2];
PTR_H = 86;
HEAP[PTR_H] = e;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = f;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = r;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = a;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = i;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = n;
PTR_H = PTR_H + 1;
HEAP[106] = 21;
PTR_H = 107;
HEAP[PTR_H] = j;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = e;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = f;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = e;
PTR_H = PTR_H + 1;
HEAP[PTR_H] =  ;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = d;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = e;
PTR_H = PTR_H + 1;
HEAP[PTR_H] =  ;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = j;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = e;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = f;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = e;
PTR_H = PTR_H + 1;
HEAP[PTR_H] = s;
PTR_H = PTR_H + 1;
STACK[7] = 1500;
STACK[8] = 3;
