INICIO -> PROYECTO

PROYECTO -> program ID ; CABECERA CUERPO begin INSTRUCCIONES end .


// *************************************** CABECERA DEL PROGRAMA ************************


CABECERA -> CABECERA CABECERA'
			| CABECERA'
			
CABECERA' -> VARIABLE
			| DECLARACION_OBJETOS
			| CONSTANTE

VARIABLE -> VARIABLE var VARIABLE'
			| var VARIABLE'
			| epsilon

VARIABLE' -> VARIABLE' DECLARACION : TIPO VARIABLE'' ;
			| DECLARACION : TIPO VARIABLE'' ;

VARIABLE'' -> = VALOR
			| epsilon

LISTA_DEC->  LISTA_DEC LISTA_DEC'
			| LISTA_DEC'

LISTA_DEC' -> DECLARACION : TIPO

DECLARACION -> DECLARACION , id
			| id
			
DECLARACION_OBJETOS -> type id = DECLARACION_OBJETOS'

DECLARACION_OBJETOS' -> ARREGLO
						| OBJETO

ARREGLO -> array[num..num] of TIPO ;

OBJETO -> object VARIABLE end ;

TIPO -> string
		| integer
		| real
		| boolean
		| void
		| object
		| id
		
VALOR -> ASIGNACION1
		|cadena
		|EXP
		|EXP_LOG

CONSTANTE -> CONSTANTE CONSTANTE'
			|CONSTANTE'
			
CONSTANTE' -> id = VALOR ;
		
		

// *************************************** CUERPO DEL PROGRAMA ************************
		

CUERPO -> CUERPO CUERPO'
		| CUERPO'
		| epsilon
		
CUERPO' -> FUNCION
		  | PROCEDIMIENTO
		  | Eof
		
FUNCION -> function id PARAMETROS : TIPO ; VARIABLE ANIDAR begin INSTRUCCIONES end ;

			 
PROCEDIMIENTO -> procedure id PARAMETROS ; VARIABLE ANIDAR begin INSTRUCCIONES end ;

ANIDAR -> ANIDAR ANIDAR'
		| ANIDAR'
		
ANIDAR' -> FUNCION
		| PROCEDIMIENTO
		| epsilon
		
PARAMETROS -> ( PARAMETROS' )
			| epsilon

PARAMETROS' -> PARAMETROS' ; PARAMETROS''
					| PARAMETROS''
					
PARAMETROS'' ->  LISTA_DEC
				 | var LISTA_DEC

LLAMADA -> id ( LLAMADA' ) ;

LLAMADA' -> LLAMADA' , VALOR
			| VALOR
			| epsilon

			
			
// **************************** INSTRUCCIONES *****************************

true and false and (false=(5<=(10))) or ((false<>true) and (true or false))


INSTRUCCIONES -> INSTRUCCIONES INSTRUCCION
				| INSTRUCCION;
				
INSTRUCCION -> IF
			| ASIGNACIONES
				
CONDICION -> EXP_LOG  

CONDICION_NUM -> CONDICION_LOG
				| <
				| >
				| <=
				| >=

CONDICION_LOG -> =
				|<>

EXP -> EXP + EXP
	|EXP - EXP
	|EXP * EXP
	|EXP / EXP
	|( EXP )
	|- EXP
	|entero
	|real
	|ASIGNACION1
	 
EXP_LOG -> EXP_LOG and EXP_LOG						3
		|EXP_LOG or EXP_LOG							3
		|( EXP_LOG )								3
		|( EXP CONDICION_NUM EXP )					5
		|( EXP_LOG CONDICION_LOG EXP_LOG )			5
		| EXP CONDICION_NUM EXP						3
		|not EXP_LOG								2
		|true										1
		|false										1
		|ASIGNACION1								1

IF -> if CONDICION then begin INSTRUCCIONES end 'IF

IF' ->   ELSE_IF IF''
		|ELSE
		|epsilon

IF'' -> ELSE
		|epsilon

ELSE_IF -> ELSE_IF else if CONDICION then begin INSTRUCCIONES end
		| else if CONDICION then begin INSTRUCCIONES end 

ELSE -> else begin INSTRUCCIONES end;
		| epsilon

CASE -> case id of LISTA_CASE ELSE_CASE end;

LISTA_CASE -> LISTA_CASE LISTA_CASE' : INSTRUCCIONES
			| LISTA_CASE' : INSTRUCCIONES
			
LISTA_CASE' -> LISTA_CASE , VALOR
			| VALOR

ELSE_CASE -> else begin INSTRUCCIONES end;
			| epsilon


WRITE -> write ( LISTA_CASE' ) ;

WRITELN -> writeln ( LISTA_CASE' ) ;

WHILE -> while CONDICION do begin INSTRUCCIONES end;

REPEAT -> repeat begin INSTRUCCIONES end until CONDICION ;

FOR -> for id : = EXP to EXP do begin INSTRUCCIONES end ;

ASIGNACIONES -> ASIGNACIONES ASIGNACION : = VALOR ;
            | ASIGNACION : = VALOR ;

ASIGNACION -> ASIGNACION . id
			| id

ASIGNACION1 -> id ASIGNACION2;

ASIGNACION2 ->  . ASIGNACION
				  | ( LLAMADA' )
				  | epsilon
				  

/*
ASIGNACIONES -> ASIGNACIONES ASIGNACION : = VALOR ;
			| ASIGNACION : = VALOR ;

ASIGNACION -> ASIGNACION . id
			| id

*/
----------------------- PRUEBAS -------------------------------------

program Hello;

type
	Rectangle = object
	var
		base, altura : integer;
		area, volumen: real;
end;

var
	r1: Rectangulo;
	n1:integer;

var
    uno, dos:integer;

procedure findMin(x, y: integer; var m,n: integer; z:integer); {m es por referencia}

	var
		r1: Rectangulo;
		n1:integer;

begin
end;


function factorial(a, b:integer) : integer;

    var
        m,n:integer;
        p:boolean;
		
begin
end;


5+5=2 and (6*(1+1))<=15 or (5+5-(6*1))>hola

5+5 = 2 and 6*(1+1)<=15

(false or true) and (5+5*(5-1))<=100

5+5*(3+(2+69))-5+6*(5+(5*3))



	






program holaMundo;

type 
    Cuadrado = object
        var
            altura:integer;
end;

type 
    Rectangulo = object
        var
            altura:integer;
            ancho:integer;
end;

type 
    Cuadrilatero = object
        var
            rectangulo:Rectangulo;
            cuadrado:Cuadrado;
end;

type 
    Circulo = object
        var
            radio:integer;
end;


type 
    Geometria = object
        var
            cuadrilatero:Cuadrilatero;
            circulo:Circulo;
end;

var geo: Geometria;
var uno, dos, tres:integer;
var circulo:Circulo;

procedure findMin(x, y: integer; var m,n: integer; z:integer); {m es por referencia}

	var
		r1: Rectangulo;
		n1:integer;

	procedure despedirse(dos:integer);
		procedure adios(tres:imteger);
		begin
		end;
	begin
	end;
begin
end;

procedure adios(tres:imteger);
		begin
		end;
		

function Ackermann(m, n : Integer) : Integer;
	
	var n1:integer='que pex';
	
	procedure despedirse(dos, tres:integer;var cuatro:string);
		procedure adios(tres:integer);
		begin
		end;
	begin
	end;
	
begin
end;


begin

	uno:=10;
	dos:=20;
	tres:=30;



	if uno+dos+tres<40 then
		begin
			geo.cuadrilatero.rectangulo.altura:=uno;
		end
	else if uno+dos+tres<50 then
		begin
			geo.cuadrilatero.rectangulo.altura:=dos;
		end
	else if uno+dos+tres=60 then
		begin						
			//geo.cuadrilatero.rectangulo.altura:=tres;
			findMin(1,3,uno,dos,5);
		end
	else
		begin
			geo.cuadrilatero.rectangulo.altura:=uno+dos+tres;
		end;

end.
	
	
	
	
function Ackermann(m, n : Integer) : Integer;
	begin
		if m = 0 then
			begin
				Ackermann := n+1;
			end
		else if n = 0 then
			begin
				Ackermann := Ackermann(m-1, 1);
			end
		else
			begin
				Ackermann := Ackermann(m-1, Ackermann(m, n-1));
			end;
	end;


program factorial;

var resultado:integer;

function fact(n: integer): integer;
	begin
		if (n = 0) then
		begin
			fact := 1;
		end
		else
		begin
			fact := n * fact(n - 1);
		end;
	end;
	
	
function ackermann(m,n: integer): integer;
	begin
		if (m = 0) then
		begin
				ackermann := n + 1
		end
		else if (m>0) AND (n = 0) then
		begin
				ackermann := ackermann(m - 1, 1)
		end
		else
		begin
				ackermann := ackermann(m - 1, ackermann(m,n - 1));
		end;
	end;


begin
	resultado:=Ackermann(4,0);
end.


(1, 0) = 2
(1, 1) = 3
(1, 1) = 



program contador;

var indice:integer;

procedure aumentar;
	begin
		indice:=indice+1;
	end;

begin
	while indice<10 do
		begin
				aumentar();
		end;
end.


program hola;

var uno:integer;

begin
	for indice:=0 to 10 do
		begin
			uno:=uno+2;
		end;
end.


program hola;

var uno:integer;

begin
	write('hola', uno);
end.



program hola;

var uno:integer;

begin

	case uno of
		1,2,3:
			begin
				writeln('El valor es menor a 4');
			end;
		4,5,6:
			begin
				writeln('El valor es menor a 7');
			end;
		7,8,9:
			begin
				writeln('El valor es menor a 10');
			end;
		else
			begin
				writeln('El valor es mayor a 10');				
			end;
end.