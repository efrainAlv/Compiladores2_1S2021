INICIO -> PROYECTO

PROYECTO -> program ID ; CABECERA CUERPO begin INSTRUCCIONES end .


// *************************************** CABECERA DEL PROGRAMA ************************


CABECERA -> CABECERA CABECERA'
			| CABECERA'
			
CABECERA' -> VARIABLE
			| DECLARACION_OBJETOS
			| CONSTANTE

VARIABLE -> VARIABLE var VARIABLE'
			| var VARIABLE'
			| epsilon

VARIABLE' -> VARIABLE' DECLARACION : TIPO VARIABLE'' ;
			| DECLARACION : TIPO VARIABLE'' ;

VARIABLE'' -> = VALOR
			| epsilon

LISTA_DEC->  LISTA_DEC LISTA_DEC'
			| LISTA_DEC'

LISTA_DEC' -> DECLARACION : TIPO

DECLARACION -> DECLARACION , id
			| id
			
DECLARACION_OBJETOS -> type id = DECLARACION_OBJETOS'

DECLARACION_OBJETOS' -> ARREGLO
						| OBJETO

ARREGLO -> array[num..num] of TIPO ;

OBJETO -> object VARIABLE end ;

TIPO -> string
		| integer
		| real
		| boolean
		| void
		| object
		| id
		
VALOR -> ASIGNACION
		|cadena
		|EXP
		|EXP_LOG
		|LLAMADA

CONSTANTE -> CONSTANTE CONSTANTE'
			|CONSTANTE'
			
CONSTANTE' -> id = VALOR ;
		
		

// *************************************** CUERPO DEL PROGRAMA ************************
		

CUERPO -> CUERPO CUERPO'
		| CUERPO'
		| epsilon
		
CUERPO' -> FUNCION
		  | PROCEDIMIENTO
		  | Eof
		
FUNCION -> function id PARAMETROS : TIPO ; VARIABLE ANIDAR begin INSTRUCCIONES end ;

			 
PROCEDIMIENTO -> procedure id PARAMETROS ; VARIABLE ANIDAR begin INSTRUCCIONES end ;

ANIDAR -> ANIDAR ANIDAR'
		| ANIDAR'
		
ANIDAR' -> FUNCION
		| PROCEDIMIENTO
		| epsilon
		
PARAMETROS -> ( PARAMETROS' )
					| epsilon

PARAMETROS' -> PARAMETROS' ; PARAMETROS''
					| PARAMETROS''
					
PARAMETROS'' ->  LISTA_DEC
				 | var LISTA_DEC

LLAMADA -> id ( LLAMADA' ) ;

LLAMADA' -> LLAMADA' , VALOR
			| VALOR
			| epsilon

			
			
// **************************** INSTRUCCIONES *****************************

true and false and (false=(5<=(10))) or ((false<>true) and (true or false))


INSTRUCCIONES -> INSTRUCCIONES INSTRUCCION
				| INSTRUCCION;
				
INSTRUCCION -> IF
			| ASIGNACIONES
				
CONDICION -> EXP_LOG
			| EXP CONDICION_NUM EXP
			| ASIGNACION 
			
CONDICION -> 

CONDICION_NUM -> CONDICION_LOG
				| <
				| >
				| <=
				| >=

CONDICION_LOG -> =
				|<>

EXP -> EXP + EXP
	|EXP - EXP
	|EXP * EXP
	|EXP / EXP
	|( EXP )
	|- EXP
	|entero
	|real
	|ASIGNACION
	|LLAMADA
	 
EXP_LOG -> EXP_LOG and EXP_LOG						3
		|EXP_LOG or EXP_LOG							3
		|( EXP_LOG )								3
		|( EXP CONDICION_NUM EXP )					5
		|( EXP_LOG CONDICION_LOG EXP_LOG )			5
		| EXP CONDICION_NUM EXP						3
		|not EXP_LOG								2
		|true										1
		|false										1
		|ASIGNACION									1
		|LLAMADA

IF -> if CONDICION then begin INSTRUCCIONES end 'IF

IF' ->   ELSE_IF IF''
		|ELSE
		|epsilon

IF'' -> ELSE
		|epsilon

ELSE_IF -> ELSE_IF else if CONDICION then begin INSTRUCCIONES end
		| else if CONDICION then begin INSTRUCCIONES end 

ELSE -> else begin INSTRUCCIONES end;
		| epsilon

CASE -> case id of LISTA_CASE ELSE_CASE end;

LISTA_CASE -> LISTA_CASE' : INSTRUCCION
			
LISTA_CASE' -> LISTA_CASE , VALOR
			| VALOR

ELSE_CASE -> else INSTRUCCION
			| epsilon


WHILE -> while CONDICION do begin INSTRUCCIONES end;

REPEAT -> repeat begin INSTRUCCIONES end until CONDICION

FOR -> id := EXP to EXP do INSTRUCCIONES

ASIGNACIONES -> ASIGNACIONES ASIGNACION : = VALOR ;
			| ASIGNACION : = VALOR ;

ASIGNACION -> ASIGNACION . id
			| id


----------------------- PRUEBAS -------------------------------------

program Hello;

type
	Rectangle = object
	var
		base, altura : integer;
		area, volumen: real;
end;

var
	r1: Rectangulo;
	n1:integer;

var
    uno, dos:integer;

procedure findMin(x, y: integer; var m,n: integer; z:integer); {m es por referencia}

	var
		r1: Rectangulo;
		n1:integer;

begin
end;


function factorial(a, b:integer) : integer;

    var
        m,n:integer;
        p:boolean;
		
begin
end;


5+5=2 and (6*(1+1))<=15 or (5+5-(6*1))>hola

5+5 = 2 and 6*(1+1)<=15

(false or true) and (5+5*(5-1))<=100

5+5*(3+(2+69))-5+6*(5+(5*3))



	






program holaMundo;

type 
    Cuadrado = object
        var
            altura:integer;
end;

type 
    Rectangulo = object
        var
            altura:integer;
            ancho:integer;
end;

type 
    Cuadrilatero = object
        var
            rectangulo:Rectangulo;
            cuadrado:Cuadrado;
end;

type 
    Circulo = object
        var
            radio:integer;
end;


type 
    Geometria = object
        var
            cuadrilatero:Cuadrilatero;
            circulo:Circulo;
end;

var geo: Geometria;
var uno, dos, tres:integer;
var circulo:Circulo;

procedure findMin(x, y: integer; var m,n: integer; z:integer); {m es por referencia}

	var
		r1: Rectangulo;
		n1:integer;

	procedure despedirse(dos:integer);
		procedure adios(tres:imteger);
		begin
		end;
	begin
	end;
begin
end;

procedure adios(tres:imteger);
		begin
		end;
		

function Ackermann(m, n : Integer) : Integer;
	
	var n1:integer='que pex';
	
	procedure despedirse(dos, tres:integer;var cuatro:string);
		procedure adios(tres:integer);
		begin
		end;
	begin
	end;
	
begin
end;


begin

	uno:=10;
	dos:=20;
	tres:=30;



	if uno+dos+tres<40 then
		begin
			geo.cuadrilatero.rectangulo.altura:=uno;
		end
	else if uno+dos+tres<50 then
		begin
			geo.cuadrilatero.rectangulo.altura:=dos;
		end
	else if uno+dos+tres=60 then
		begin						
			//geo.cuadrilatero.rectangulo.altura:=tres;
			findMin(1,3,uno,dos,5);
		end
	else
		begin
			geo.cuadrilatero.rectangulo.altura:=uno+dos+tres;
		end;

end.
	
	
	
	
function Ackermann(m, n : Integer) : Integer;
	begin
		if m = 0 then
			begin
				Ackermann := n+1
			end
		else if n = 0 then
			begin
				Ackermann := Ackermann(m-1, 1)
			end
		else
			begin
				Ackermann := Ackermann(m-1, Ackermann(m, n-1));
			end;
	end;


program Hello;

var adios:integer;


function hola(uno, dos:integer):integer;
    begin
        hola:=uno+dos;
    end;


begin

	adios:=hola(27, 39);
    
end.


id

node ()

